<template>
	<div class="device-map-container">
		<l-map ref="map" :zoom="zoom" :center="center" @ready="handleMapReady">
			<l-tile-layer :url="url" :attribution="attribution"></l-tile-layer>
			<l-marker v-for="device in devices" :key="device.device_id" :lat-lng="getLatLng(device)">
				<MapMarkerIcon :deviceId="device.device_id" :color="device.color" />
			</l-marker>
		</l-map>
	</div>

</template>


<script setup lang="ts">
import { inject, nextTick, h, ref, onMounted, watch, onUnmounted, defineComponent } from 'vue';
import 'leaflet/dist/leaflet.css';
import * as L from 'leaflet'; // Correct import
import { LMap, LTileLayer, LMarker, LIcon } from '@vue-leaflet/vue-leaflet'; // Import LMarker and LIcon
import type { Device } from '@/types/device';
import { useUserStore } from '@/stores/userStore';
import { storeToRefs } from 'pinia';
import _ from 'lodash';
import MapMarkerIcon from './MapMarkerIcon.vue';
import { renderToString } from 'vue/server-renderer';

const zoom = ref(6);
const center = ref([37.25, -119.75]);  // Initial center point (California)
const url = ref('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');  // Base tile layer URL
//Have to include attribution otherwise it is going to show blank
const attribution = ref('&copy; <a target="_blank" href="http://osm.org/copyright">OpenStreetMap</a> contributors');

const userStore = useUserStore();
const { devices } = storeToRefs(userStore);

// Correctly set Leaflet icon paths. Just a workaround for this library
L.Icon.Default.mergeOptions({
	iconRetinaUrl: new URL('leaflet/dist/images/marker-icon-2x.png', import.meta.url).href,
	iconUrl: new URL('leaflet/dist/images/marker-icon.png', import.meta.url).href,
	shadowUrl: new URL('leaflet/dist/images/marker-shadow.png', import.meta.url).href,
});

const getLatLng = (device: Device): L.LatLngTuple => { // Explicitly return L.LatLngTuple
	if (device.latest_device_point && device.latest_device_point.lat && device.latest_device_point.lng) {
		return [device.latest_device_point.lat, device.latest_device_point.lng] as L.LatLngTuple; // Type assertion if needed
	}
	return center.value as L.LatLngTuple; // Use type assertion
};

// Create a ref to hold the injected layout preference
const injectedLayoutPreference = inject<string | undefined>('layoutPreference');
const layoutPreference = ref(injectedLayoutPreference);

const map = ref();
let mapReady = ref(false);

const handleMapReady = () => {
	mapReady.value = true;
	updateMarkers();
};

// const getIcon = (device:Device) => {
// 	// Existing getIcon logic - construct icon based on iconURL or color
// 	console.log("getIcon", device);
// 	if (device.iconURL) {
// 		return new L.Icon({

// 			iconUrl: device.iconURL,
// 			iconSize: [32, 32],
// 			iconAnchor: [16, 32],
// 		});
// 	}
// 	const color = device.color || 'blue';

// 	return new L.Icon({
// 		iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`,
// 		iconSize: [25, 41],
// 		iconAnchor: [12, 41],
// 	});

// };

const isSelected = (device: Device) => {
	return props.selectedDevice?.device_id === device.device_id;
};

const debouncedUpdateMarkers = _.debounce(() => {
	updateMarkers();
}, 300);


const markers = ref({});  // Stores markers by device_id
const { getDeviceIcon } = userStore; 

const createMarker = async (device: Device) => {
    console.log("Creating marker for device", device);

    if (!map.value || !map.value.mapObject || !device.latest_device_point) {
        return;
    }


    const latLng = getLatLng(device);

	try {
		// Use getDeviceIcon from the store:
		const iconUrl = await getDeviceIcon(device);  // Use the centralized function and await

		const iconComponent = defineComponent({ // Corrected defineComponent
			template: `<MapMarkerIcon :iconUrl="iconUrl" :color="device.color" />`,  // Simplified template
			props: ['device', 'iconUrl'],  // No need to pass the entire device if you have the iconUrl
			components: { MapMarkerIcon }

		});

		const iconHtml = await renderToString(h(iconComponent, { iconUrl: iconUrl, device: device })); // Pass iconUrl to component


		const icon = L.divIcon({
			html: iconHtml,
			className: "",
			iconSize: [24, 36], 
			iconAnchor: [12, 36],
			popupAnchor: [0, -36]
		});

		const marker = L.marker(latLng, { icon }).addTo(map.value.mapObject);
		markers.value[device.device_id] = marker;

	} catch (error) {
		console.error('Error creating marker:', error); // Enhanced error handling
		// Handle the error, perhaps add a default marker or log the error
	}


};




const updateMarkers = async() => {
	if (!map.value?.mapObject || !devices.value) {
		return;  // No devices yet
	}

	for (const deviceId in markers.value) { // Clear existing markers
		markers.value[deviceId].remove();
	}
	markers.value = {};


	for (const device of devices.value) {
		await createMarker(device); // Wait for createMarker which is now async
	}
};


// Watch for changes to the devices array and re-render markers if needed
watch(() => devices.value, () => { // Correctly call fitBounds in the watcher

	console.log(devices);
	if (map.value?.mapObject && devices.value.length > 0) { // Check if map and devices are available
		map.value.mapObject.fitBounds(devices.value.map(device => getLatLng(device))); // Call fitBounds here
	}
}, { deep: true });

</script>

<style scoped>
.device-map-container {
	height: 100%;
	width: 100%;
}
</style>